{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Django lazy managers \ud83d\udd17 1 pip install django-lazy-managers Documentation : https://mrthearman.github.io/django-lazy-managers/ Source Code : https://github.com/MrThearMan/django-lazy-managers/ Contributing : https://github.com/MrThearMan/django-lazy-managers/blob/main/CONTRIBUTING.md Lazy model managers for Django","title":"Home"},{"location":"#django-lazy-managers","text":"1 pip install django-lazy-managers Documentation : https://mrthearman.github.io/django-lazy-managers/ Source Code : https://github.com/MrThearMan/django-lazy-managers/ Contributing : https://github.com/MrThearMan/django-lazy-managers/blob/main/CONTRIBUTING.md Lazy model managers for Django","title":"Django lazy managers"},{"location":"example/","text":"Example \ud83d\udd17 Lazy managers \ud83d\udd17 Given the following models: 1 2 3 4 5 6 7 8 9 10 11 12 13 from django.db import models class Project ( models . Model ): name = models . CharField ( max_length = 255 ) description = models . TextField () created_at = models . DateTimeField ( auto_now_add = True ) class Task ( models . Model ): name = models . CharField ( max_length = 255 ) description = models . TextField () created_at = models . DateTimeField ( auto_now_add = True ) project = models . ForeignKey ( Project , on_delete = models . CASCADE , related_name = \"tasks\" ) We can delay the evaluation of a manager with the LazyModelManager descriptor: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from typing import ClassVar , TYPE_CHECKING from django.db import models from lazy_managers import LazyModelManager if TYPE_CHECKING : from .querysets import ProjectManager , TaskManager class Project ( models . Model ): name = models . CharField ( max_length = 255 ) description = models . TextField () created_at = models . DateTimeField ( auto_now_add = True ) objects : ClassVar [ ProjectManager ] = LazyModelManager . new () class Task ( models . Model ): name = models . CharField ( max_length = 255 ) description = models . TextField () created_at = models . DateTimeField ( auto_now_add = True ) project = models . ForeignKey ( Project , on_delete = models . CASCADE , related_name = \"tasks\" ) objects : ClassVar [ TaskManager ] = LazyModelManager . new () With this, our manager (and queryset) classes will be lazily loaded when it is first accessed, either from the class itself, or from a to-many relationship. The advantage of this is that our manager (and queryset) module can freely import other modules without causing cyclical imports. Lazy attributes \ud83d\udd17 The library also provides a way to lazily load other attributes on a model, with the same benefits of avoiding cyclical imports. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from typing import ClassVar , TYPE_CHECKING from django.db import models from lazy_managers import LazyModelAttribute if TYPE_CHECKING : from .validators import ProjectValidators , TaskValidators class Project ( models . Model ): name = models . CharField ( max_length = 255 ) description = models . TextField () created_at = models . DateTimeField ( auto_now_add = True ) validators : ClassVar [ ProjectValidators ] = LazyModelAttribute . new () class Task ( models . Model ): name = models . CharField ( max_length = 255 ) description = models . TextField () created_at = models . DateTimeField ( auto_now_add = True ) project = models . ForeignKey ( Project , on_delete = models . CASCADE , related_name = \"tasks\" ) validators : ClassVar [ TaskValidators ] = LazyModelAttribute . new () Here the attribute should take a single argument, which is the instance of the model being accessed. However, the attribute can be accessed on the class level, in which case the attribute class itself will be given from the descriptor.","title":"Examples"},{"location":"example/#example","text":"","title":"Example"},{"location":"example/#lazy-managers","text":"Given the following models: 1 2 3 4 5 6 7 8 9 10 11 12 13 from django.db import models class Project ( models . Model ): name = models . CharField ( max_length = 255 ) description = models . TextField () created_at = models . DateTimeField ( auto_now_add = True ) class Task ( models . Model ): name = models . CharField ( max_length = 255 ) description = models . TextField () created_at = models . DateTimeField ( auto_now_add = True ) project = models . ForeignKey ( Project , on_delete = models . CASCADE , related_name = \"tasks\" ) We can delay the evaluation of a manager with the LazyModelManager descriptor: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from typing import ClassVar , TYPE_CHECKING from django.db import models from lazy_managers import LazyModelManager if TYPE_CHECKING : from .querysets import ProjectManager , TaskManager class Project ( models . Model ): name = models . CharField ( max_length = 255 ) description = models . TextField () created_at = models . DateTimeField ( auto_now_add = True ) objects : ClassVar [ ProjectManager ] = LazyModelManager . new () class Task ( models . Model ): name = models . CharField ( max_length = 255 ) description = models . TextField () created_at = models . DateTimeField ( auto_now_add = True ) project = models . ForeignKey ( Project , on_delete = models . CASCADE , related_name = \"tasks\" ) objects : ClassVar [ TaskManager ] = LazyModelManager . new () With this, our manager (and queryset) classes will be lazily loaded when it is first accessed, either from the class itself, or from a to-many relationship. The advantage of this is that our manager (and queryset) module can freely import other modules without causing cyclical imports.","title":"Lazy managers"},{"location":"example/#lazy-attributes","text":"The library also provides a way to lazily load other attributes on a model, with the same benefits of avoiding cyclical imports. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from typing import ClassVar , TYPE_CHECKING from django.db import models from lazy_managers import LazyModelAttribute if TYPE_CHECKING : from .validators import ProjectValidators , TaskValidators class Project ( models . Model ): name = models . CharField ( max_length = 255 ) description = models . TextField () created_at = models . DateTimeField ( auto_now_add = True ) validators : ClassVar [ ProjectValidators ] = LazyModelAttribute . new () class Task ( models . Model ): name = models . CharField ( max_length = 255 ) description = models . TextField () created_at = models . DateTimeField ( auto_now_add = True ) project = models . ForeignKey ( Project , on_delete = models . CASCADE , related_name = \"tasks\" ) validators : ClassVar [ TaskValidators ] = LazyModelAttribute . new () Here the attribute should take a single argument, which is the instance of the model being accessed. However, the attribute can be accessed on the class level, in which case the attribute class itself will be given from the descriptor.","title":"Lazy attributes"}]}